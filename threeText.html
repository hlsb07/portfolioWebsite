<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2D Canvas: Text & Bild animieren</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0f1115; }
    canvas { display: block; width: 100%; height: 100%; }
    .hint { position: fixed; left: 12px; bottom: 12px; color: #9ad0ff; font: 14px/1.4 system-ui, sans-serif; opacity: .9; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hint">Beispiel: 2D-Canvasâ€”Text & Bild animiert</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // DPR-Scaling fÃ¼r scharfe Darstellung
  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const { innerWidth: w, innerHeight: h } = window;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resize();
  addEventListener('resize', resize);

  // Ein "Bild" als eingebettetes SVG (keine externen Dateien nÃ¶tig)
  const svg = `
    <svg xmlns='http://www.w3.org/2000/svg' width='240' height='240' viewBox='0 0 240 240'>
      <defs>
        <linearGradient id='g' x1='0' y1='0' x2='1' y2='1'>
          <stop offset='0%' stop-color='#9ad0ff'/>
          <stop offset='100%' stop-color='#2b6cb0'/>
        </linearGradient>
      </defs>
      <circle cx='120' cy='120' r='110' fill='url(#g)'/>
      <path d='M70 120 L120 60 L170 120 L120 180 Z' fill='white' fill-opacity='.9'/>
    </svg>`;
  const IMG_SRC = 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
  const img = new Image();
  img.src = IMG_SRC;

  let t0 = performance.now();

  function drawBackground(w, h) {
    // Sanfter Verlaufs-Hintergrund
    const grad = ctx.createLinearGradient(0, 0, w, h);
    grad.addColorStop(0, '#0f1115');
    grad.addColorStop(1, '#151a23');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    // Leichte KÃ¶rnung (pro Frame fix), optional: dezent
    ctx.globalAlpha = 0.04;
    for (let i = 0; i < 80; i++) {
      const x = Math.random() * w;
      const y = Math.random() * h;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(x, y, 1, 1);
    }
    ctx.globalAlpha = 1;
  }

  function drawText(w, h, t) {
    const baseX = w * 0.52;
    const baseY = h * 0.5;
    const slide = Math.sin(t * 0.5) * 40;     // horizontales Gleiten
    const pulse = 1 + Math.sin(t * 2) * 0.05; // leichter Scale-Puls
    const fade = 0.6 + 0.4 * (0.5 + 0.5 * Math.sin(t * 1.2)); // 0.6â€“1.0

    ctx.save();
    ctx.translate(baseX + slide, baseY);
    ctx.scale(pulse, pulse);

    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';

    // Outline
    ctx.lineWidth = 6;
    ctx.strokeStyle = '#003b6f';
    ctx.font = 'bold 64px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.strokeText('Hallo 2D-Canvas ðŸ‘‹', 0, -24);

    // FÃ¼llung
    ctx.globalAlpha = fade;
    ctx.fillStyle = '#9ad0ff';
    ctx.fillText('Hallo 2D-Canvas ðŸ‘‹', 0, -24);

    // Subline
    ctx.globalAlpha = 0.9;
    ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.fillStyle = '#b4c7dd';
    ctx.fillText('Text & Bild animieren â€“ ohne Libraries', 4, 24);

    ctx.restore();
  }

  function drawImage(w, h, t) {
    if (!img.complete) return; // warten, bis Daten-URL geladen ist

    const cx = w * 0.3;
    const cy = h * 0.5;
    const bob = Math.sin(t * 0.8) * 15;  // leichtes Schweben
    const rot = Math.sin(t * 0.6) * 0.12;

    const targetW = Math.min(260, w * 0.35);
    const targetH = targetW; // SVG ist quadratisch

    ctx.save();
    ctx.translate(cx, cy + bob);
    ctx.rotate(rot);
    ctx.globalAlpha = 0.95;

    // sanfter Schatten
    ctx.shadowColor = 'rgba(0,0,0,0.6)';
    ctx.shadowBlur = 24;
    ctx.shadowOffsetY = 8;

    ctx.drawImage(img, -targetW/2, -targetH/2, targetW, targetH);
    ctx.restore();
  }

  function loop(now) {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const t = (now - t0) / 1000;

    drawBackground(w, h);
    drawImage(w, h, t);
    drawText(w, h, t);

    requestAnimationFrame(loop);
  }

  // Start, wenn das (eingebettete) Bild fertig ist
  if (img.complete) requestAnimationFrame(loop);
  else img.onload = () => requestAnimationFrame(loop);
})();
</script>
</body>
</html>
